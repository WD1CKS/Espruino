//var font_cp437_8x8 = atob("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");
//var width_cp437_8x8 = atob("BQgICAgICAUIBwgIBwgICAgIBwUICAcIBgYICAcICAgFBAUHBwcIAwQECAYDBwIHBwYHBwgHBwcHBwIDBQcFBwcHBwcHBwcHBwQHBwcHBwcHBwcHBwcHBwcHBwUIBQgIAwcHBwcHBgcHBAcHBAcHBwcHBwcHBwcHBgcGBgIGBwcHBwcHBwcHBwcHBwUIBQcHBgcHBwcHBwcHBwcHBwYICAcEBwcHBwcGBwcHCAgCBwcICAgCBQUHBwUHBAcHBwUFBQgIBQgIBQUFBQgIBQgICAgICAUFBQUICAUFCAgFBAgHBwcHBwcIBwYHBwcICAUHBwYHBwUFBwcFAwMIBgUFBQUICAgICAgFCAcICAcICAgICAcHCAgHCAcHCAgICAgIBQUGCAcICAQFBQgHBAcDCAgHBwcIBwcHBwcDBAYHBgcIBwgICAgICAcFCAgICAgICAcIBwcHBwgIBwgFCAUICAQICAcIBwcICAUHCAUIBwcICAgHBggHCAgHBwcDBwgIBwgHCAgICAcIBwcHCAYIBwcICAcHBwgIBwgHCAgHCAgIBQcIBwcHBgcHBwgIAwgICAgIAwYGCAgGCAYICAgGBgUICAUICAUGBgYICAYICAgICAgGBQUGCAgGBQgIBQQICAcHCAcICAgHCAgHCAgGBwcHBwcFBgcIBgMDCAYFBQU=");

function clamp(min, max, val) {
	return (val >= min && val <= max ? val : (val < min ? min : max));
}

function draw_bargraph(x, y, w, h, steps, bg, lo, md, hi, val) {
	LCD.setColor.apply(LCD, bg);
	LCD.fillRect(x, y, x + w - 1, y + h - 1);
	var bw = Math.floor(w / steps); // width of an individual bar
	var nb = Math.round((w / bw) * val); // number of bars to show
	if (nb < 1) return; // We've cleared the space and don't need to show anything
	LCD.setColor.apply(LCD, val >= .66 ? hi : (val >= .33 ? md : lo));
	for (var n = 0; n < nb; n++) {
		var sx = x + (n * bw);
		var ex = sx + bw - 1;
		var ey = y + h - 1;
		var sy = ey - Math.floor((h / steps) * n); // top y of this bar
		LCD.fillRect(sx, sy, ex, ey);
	}
}

function md380() {
//  LCD.setFontCustom(font_cp437_8x8, 0, width_cp437_8x8, 8);
}

md380.prototype.set_backlight = function (val, freq) {
	analogWrite(C6, clamp(0, 1, val), { freq : freq || 120 });
}

md380.prototype.set_led = function (led, on) {
	digitalWrite(led == 0 ? E0 : E1, on ? HIGH : LOW);
}

md380.prototype.StatusBar = function () {

	const SB_X = 0;
	const SB_Y = 115;
	const SB_W = 160;
	const SB_H = 12;
	const SB_IC_H = SB_H - 4;
	const SB_IC_Y = 117;

	const RSSI_X = 4;
	const RSSI_W = 26;

	const SPK_X = 74;

	const BATT_X = 140;
	const BATT_W = 16;

	const COLOR_LO = [ .84, .12, .22 ];
	const COLOR_MD = [ 1, .52, 0 ];
	const COLOR_HI = [ 0, .75, .12 ];

	const COLOR_SB = [ .77, .77, .77 ]; // Status bar
	const COLOR_BD = [ 0, 0, 0 ]; // Borders

	this.update_battery = function (val) {
		// Clear dynamic area
		LCD.setColor.apply(LCD, COLOR_SB);
		LCD.fillRect(BATT_X + 1, SB_IC_Y + 1, BATT_X + BATT_W - 3, SB_IC_Y + SB_IC_H - 2);
		// Fill with appropriate width & colour
		LCD.setColor.apply(LCD, val >= .5 ? COLOR_HI : (val >= .25 ? COLOR_MD : COLOR_LO));
		LCD.fillRect(BATT_X + 1, SB_IC_Y + 1, BATT_X + 1 + Math.floor((BATT_W - 4) * val), SB_IC_Y + SB_IC_H - 2);
		// Overlay level markers
		LCD.setColor.apply(LCD, COLOR_BD);
		for (var n = 1; n < 6; n++) {
			var xx = BATT_X + 1 + (2 * n);
			LCD.drawLine(xx, SB_IC_Y + 1, xx, SB_IC_Y + SB_IC_H - 2);
		}
	}

	this.update_rssi = function (val) {
		draw_bargraph(RSSI_X + 1, SB_IC_Y, RSSI_W - 2, SB_IC_H - 1, 6, COLOR_SB, COLOR_LO, COLOR_MD, COLOR_HI, clamp(0, 1, val));
	}

	this.update_volume = function (val) {
		var sx = SPK_X + 6;
		// Clear dynamic area
		LCD.setColor.apply(LCD, COLOR_SB);
		LCD.fillRect(sx, SB_IC_Y - 1, sx + 19, SB_IC_Y + SB_IC_H);
		// Find number of bars to draw
		var bars = Math.round((clamp(0, 1, val) * 100) / 10);
		if (bars < 1) return;
		LCD.setColor.apply(LCD, COLOR_BD);
		for (var n = 0; n < bars; n++) {
			var _sx = sx + (n * 2);
			var _sy = SB_IC_Y + 3 - Math.floor(n / 2);
			var _ey = SB_IC_Y + 4 + Math.floor(n / 2);
			LCD.drawLine(_sx, _sy, _sx, _ey);
		}
	}

	this.draw_static = function () {
		// Status bar background
		LCD.setColor.apply(LCD, COLOR_SB);
		LCD.fillRect(SB_X, SB_Y, SB_X + SB_W - 1, SB_Y + SB_H - 1);
		LCD.setColor.apply(LCD, COLOR_BD);
		// S-Meter outline
		LCD.drawLine(RSSI_X, SB_IC_Y, RSSI_X, SB_IC_Y + SB_IC_H - 2);
		LCD.drawLine(RSSI_X, SB_IC_Y + SB_IC_H - 1, RSSI_X + RSSI_W - 1, SB_IC_Y + SB_IC_H - 1);
		LCD.drawLine(RSSI_X + RSSI_W - 1, SB_IC_Y + 1, RSSI_X + RSSI_W - 1, SB_IC_Y + SB_IC_H - 2);
		// Speaker icon
		LCD.fillPoly([SPK_X, SB_IC_Y + 2, SPK_X + 2, SB_IC_Y + 2, SPK_X + 4, SB_IC_Y, SPK_X + 4, SB_IC_Y + 7, SPK_X + 2, SB_IC_Y + 5, SPK_X, SB_IC_Y + 5]);
		// Battery outline
		LCD.drawRect(BATT_X, SB_IC_Y, BATT_X + BATT_W - 2, SB_IC_Y + SB_IC_H - 1);
		LCD.drawRect(BATT_X + BATT_W - 1, SB_IC_Y + 2, BATT_X + BATT_W, SB_IC_Y + SB_IC_H - 2);
	}

	this.demo = function (cease) {
		var evt = { rssi : null, vol : null, batt : null }, rssi = 0, vol = 0, batt = 0;
		if (cease) {
			Object.keys(evt).forEach((e) => { if (evt[e] !== null) clearInterval(evt[e]); });
		} else {
			this.draw_static();
			var self = this;
			evt.rssi = setInterval(() => { self.update_rssi(rssi); rssi = (rssi + .1) % 1.1; }, 300);
			evt.vol = setInterval(() => { self.update_volume(vol); vol = (vol + .1) % 1.1; }, 250);
			evt.batt = setInterval(() => { self.update_battery(batt); batt = (batt + .1) % 1.1; }, 200);
		}
	}

}

md380.prototype.ReadSecurity = function (addr) {
	var ret;
	D7.reset();
	SPI1.setup({sck:B3, miso:B4, mosi:B5, baud:84000000, mode:3});
	SPI1.send([0x48, (addr>>16)&0xff, (addr>>8)&0xff, (addr)&0xff, 0xA5]);
	ret = SPI1.send([0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5, 0xA5]);
	D7.set();
	return ret;
};

md380.prototype.cs_5000_read = function(reg) {
	E6.reset();
	var c5 = new SPI();
	c5.setup({sck:C13, miso:E3, mosi:E5, mode:1});
	var ret = c5.send([0x80, reg, 0xa5], E2);
	return ret[2];
};

md380.prototype.cs_5000_write = function (reg, val) {
	E6.reset();
	var c5 = new SPI();
	c5.setup({sck:C13, miso:E3, mosi:E5, mode:1});
	c5.send([0x00, reg, val], E2);
};

md380.prototype.init_pins = function() {
	A0.mode('analog');			// Volume pot input (Labeled as "TX_LED")
	A1.mode('analog');			// Main battery level, divided by three
	A2.mode('analog');			// ?? Analog FM in?
	A3.mode('analog');			// ?? VOX
	A4.mode('analog');			// ?? APC/TV
	analogWrite(A4, 0, {soft:false});
	A5.mode('analog');			// ?? MOD2_BIAS
	analogWrite(A5, 0, {soft:false});
	A6.mode('input_pullup');		// Keypad (K1)
	A7.mode('output');			// Power switch override
	A7.reset();
	A8.mode('output');			// ?? "SAVE" Controls the 5C power bus, needed at least for analog FM RX
	A8.reset();
	A9.mode('output');			// ?? VCOVCC_SW Needs to be set to RX analog FM. Schematic suggests needs to be reset for TX??
	A9.reset();
	A10.mode('output');			// ?? DMR_SW
	A10.reset();
	//A11.mode('af_output');		// USB USB_D-
	//A12.mode('af_output');		// USB USB_D+
	A13.mode('output');			// Wide/Narrow FM switch Set is Wide, Reset is Narrow W/N_SW
	A13.reset();
	A14.mode('output');			// ?? MICPWR_SW
	A14.reset();
	A15.mode('af_output');			// ?? AF6, I2S_FS

	B0.mode('analog');			// Receive Signal Strength Indicator RSSI
	B1.mode('analog');			// ?? FM IF Detector "NREC" (Rectifier Output - Noise Detection Output) BUSY
	B2.mode('output');			// ?? Seems to toggle FM audio input on A2, not verified FM_SW
	B2.reset();
	//B3.mode('af_output');			// SPI1 (Flash) SCLK
	//B4.mode('af_output');			// SPI1 (Flash) SDO
	//B5.mode('af_output');			// SPI1 (Flash) SDI
	SPI1.setup({sck:B3, miso:B4, mosi:B5, baud:84000000, mode:3});
	//B6.mode('af_opendrain');		// ?? I2C1 SCL
	//B7.mode('af_opendrain');		// ?? I2C1 SDA
	I2C1.setup({scl:B6, sda:B7, bitrate:400000});
	B8.mode('output');			// Speaker mute SPK_C
	B8.set();
	B9.mode('output');			// AF Amplifier AFCO
	B9.reset();
	B10.mode('input_pullup');		// Rotato ECN2
	B11.mode('input_pullup');		// Rotato RCN3
	B12.mode('output');			// ?? C5000 thing V_CS (Vocoder?)
	B12.set();
	//B13.mode('af_output');		// ?? C5000 thing V_SCLK (Vocoder?)
	//B14.mode('af_output');		// ?? C5000 thing V_SDO (Vocoder?)
	//B15.mode('af_output');		// ?? C5000 thing V_SDO (Vocoder?)
	SPI2.setup({sck:B13, miso:B14, mosi:B15, baud:84000000, mode:3});

	C0.mode('input');			// ?? TIME_SLOT_INTER
	C1.mode('input');			// ?? SYS_INTER
	C2.mode('input');			// ?? RF_TX_INTER
	C3.mode('analog');			// ?? 2T/5T (And RF_RX_INTER -- not connected?)
	C4.mode('output');			// RF Amplifier RF_APC_SW - Has blown up one radio when pulled high during RX (AF amp and Analog FM enabled)
	C4.reset();
	C5.mode('output');			// ?? 5TC seems to switch RF TX path (Analog FM only?)
	C5.reset();
	C6.mode('output');			// LCD Backlight LAMP
	//C6.reset();				// Don't touch, part of LCD library
	C7.mode('opendrain');			// ?? CTC/DCS_OUT
	C8.mode('output');			// Noise generator when AF amp is on PWM through LPF VOL_OUT ?? 2T/5T/DTMF_OUT output (beeps, and tones during transmit?)
	C8.reset();
	C9.mode('output');			// ?? 5RC Switches RX "stuff" seems to be Analog FM only?
	C9.reset();
	//C10.mode('af_output');		// ?? I2S_CK AF-6
	//C11.mode('af_output');		// ?? I2S_RX AF 5
	//C12.mode('af_output');		// ?? I2S_TX AF=6
	// TODO: I2S?	Anyone?
	SPI3.setup({sck:C10, miso:C11, mosi:C12, baud:84000000, mode:3});
	C13.mode('output');			// DMR "user" SPI Clock BSHIFT
	C13.reset();
	C14.mode('input');			// ?? 32.768K_IN
	C15.mode('input');			// ?? 32.768K_OUT

	//D0.mode('af_output');			// LCD D2 - FSMC
	//D1.mode('af_output');			// LCD D3 - FSMC
	D2.mode('input');			// Keypad - K2
	D3.mode('input');			// Keypad - K3
	//D4.mode('af_output');			// LCD RD - FSMC
	//D5.mode('af_output');			// LCD_WR - FSMC
	D6.mode('output');			// LCD Chip Select - Active Low
	D6.set();
	D7.mode('output');			// SPI1 Flash Chip Select - Active Low FLASH_CS0
	D7.set();
	D8.mode('output');			// ?? Flash CS1 (active low), nothing here?
	D8.set();
	D9.mode('output');			// ?? Flash CS2 (active low), nothing here?
	D9.set();
	D10.mode('input');			// Lock detected on PLL chip - PLL_LD
	D11.mode('output');			// PLL chip select - Active Low PLL_CS
	D11.set();
	//D12.mode('af_output');		// LCD_RS - FSMC
	D13.mode('output');			// LCD Reset - LCD_RST
	//D13.set();				// Leave it alone, part of LCD library
	//D14.mode('af_output');		// LCD D0 - FSMC
	//D15.mode('af_output');		// LCD D1 - FSMC

	E0.mode('output');			// Green (RX) LED
	E0.reset();
	E1.mode('output');			// Red (TX) LED
	E1.reset();
	E2.mode('output');			// DMR "user" SPI Chip Select - Active Low
	E2.set();
	E3.mode('input');			// DMR "user" SPI Input (DMR_SCLK/PLL_CLK on schematic appears wrong)
	E4.mode('output');			// PLL serial data clock ("DMR_SDO" on schematic appears wrong)
	E4.reset();
	E5.mode('output');			// PLL Data output, DMR "user" SPI Data output DMR_SDI/PLL_DAT
	E5.reset();
	E6.mode('output');			// ?? DMR_SLEEP
	E6.reset();
	//E7.mode('af_output');			// LCD D4 - FSMC
	//E8.mode('af_output');			// LCD D5 - FSMC
	//E9.mode('af_output');			// LCD D6 - FSMC
	//E10.mode('af_output');		// LCD D6 - FSMC
	E11.mode('input');			// PTT Key
	E12.mode('input');			// External PTT Key
	E13.mode('output');			// FM_MUTE Active Low (ie: FM is muted when this is low)
	E13.reset();
	E14.mode('input');			// Rotato ECN0
	E15.mode('input');			// Rotato ECN1
};

md380.prototype.fm_mode = function(freq) {
	this.init_pins();
	A8.set();
	A9.set();
	A13.set();
	B2.set();
	C7.set();
	C9.set();
	if (freq !== undefined) {
		if (!this.set_freq(freq))
			return false;
	}
	B8.reset();
	B9.set();
	E13.set();
	return true;
};

var last_vco_freq = 0;
function set_vco(freq, high_res) {
	const osc = 16.8;
	var Mdiv;
	var fractional;
	var divider;
	var dividend;
	var j;

	function prog_sky(addr, val) {
		var i;
		var cmb = ((addr & 0xf) << 12) | (val & 0xfff);
		D11.reset();
		E4.set();
		for (i=15; i>=0; i--) {
			E5.write(cmb & (1<<i) ? 1 : 0);
			E4.reset();
			E4.set();
		}
		D11.set();
	}

	if (high_res === undefined)
		high_res = false;

	Mdiv = 32;
	fractional = freq / (osc / Mdiv);
	while(fractional >= 537.5) {
		Mdiv--;
		fractional = freq / (osc / Mdiv);
		if (Mdiv >= 32) {
			console.log("Can't get fractional low enough!");
			return false;
		}
	}
	divider = Math.round(fractional) - 32;
	if (divider < 6) {
		console.log("Divider "+divider+" out of range!");
		return false;
	}
	if (high_res)
		dividend = Math.round(262144 * (fractional - divider - 32));
	else
		dividend = Math.round(1024 * (fractional - divider - 32));

	if (high_res)
		prog_sky(7, 0x00);
	else
		prog_sky(7, 0x08);
	prog_sky(5, Mdiv-1);
	prog_sky(0, divider);
	// And finally the dividend
	if (high_res) {
		prog_sky(2, dividend & 0xff);
		prog_sky(1, dividend >> 8);
	}
	else {
		prog_sky(1, dividend);
	}

	// Wait for PLL lock...
	for (j=0; j<10; j++) {
		if (D10.read())
			break;
	}
	if (j === 10)
		return false;

	if (high_res)
		last_vco_freq = (((dividend / 262144) + 32 + divider)*osc/Mdiv);
	else
		last_vco_freq = (((dividend / 1024) + 32 + divider)*osc/Mdiv);

	return last_vco_freq;
}

var last_set_freq = 0;
md380.prototype.set_freq = function(freq, high) {
	var ret;

	if (isNaN(freq))
		return false;

	// TODO: Handle VHF radios as well
	if (freq < 400 || freq > 480)
		return false;
	ret = set_vco(freq-49.9415, high);
	if (ret === false)
		return false;
	last_set_freq = ret+49.9415;
	return true;
};

md380.prototype.get_freq = function() {
	return last_set_freq;
};

md380.prototype.scan = function(start, end, step, squelch) {
	// TODO: Handle VHF radios as well
	if (start === undefined)
		start = 400;
	if (end === undefined)
		end = 480;
	if (step === undefined)
		step = 0.0125;
	if (squelch === undefined)
		squelch = 0.4;

	if (step == 0)
		return false;

	if (start < 400 || start > 480)
		return false;

	if (end < 400 || end > 480)
		return false;

	var freq = start;
	var rssi;

	this.fm_mode(freq);
	while((freq <= end && freq >= start) || (freq <= start && freq >= end)) {
		if (this.set_freq(freq)) {
			rssi = analogRead(B0);
			if (rssi > squelch)
				return last_set_freq;
			freq += step;
		}
		else
			return false;
	}
	return false;
};

// const COLOR_BG = [ .45, .63, .90 ]; // Background
// LCD.setColor.apply(LCD, COLOR_BG);
// LCD.fillRect(0, 0, 159, 114);
// var md = require('md380').get();
// var sb = new md.StatusBar();
// sb.draw_static();
// sb.demo();

exports.get = function () {
	return new md380();
}
